package main

import (
	"os"
	"reflect"
	"text/template"
	"time" // Added to demonstrate safety with time.Time
)

// --- Structs Definitions ---

type NetworkPatch struct {
	unexported      *string
	NonPointerField string
	IP              *string
	MacAddress      *string
}

type AgentPatch struct {
	Phase *string
	// Nested Level 1
	Network *NetworkPatch
	// Nested Level 1 (but standard library, should NOT be recursively merged)
	LastSeen *time.Time
}

type ClusterPatch struct {
	Region *string
	// Nested Level 2 (Cluster -> Agent -> Network)
	MainAgent *AgentPatch
}

// Config: Add all structs you want to generate Merge logic for here
var targetTypes = []interface{}{
	ClusterPatch{},
	AgentPatch{},
	NetworkPatch{},
}

// --- Generator Logic ---

const mergeTmpl = `
// Code generated by gen_merge; DO NOT EDIT.
package api

{{ range . }}
func Merge{{ .Name }}(existing, new *{{ .Name }}) {
	if new == nil {
		return
	}
{{- range .Fields }}
	{{- if .IsMergeableStruct }}
	if new.{{ .Name }} != nil {
		if existing.{{ .Name }} == nil {
			existing.{{ .Name }} = new.{{ .Name }}
		} else {
			Merge{{ .TypeName }}(existing.{{ .Name }}, new.{{ .Name }})
		}
	}
	{{- else }}
	if new.{{ .Name }} != nil {
		existing.{{ .Name }} = new.{{ .Name }}
	}
	{{- end }}
{{- end }}
}
{{ end }}
`

type FieldData struct {
	Name              string
	TypeName          string
	IsMergeableStruct bool // Only true if the type is in our target list
}

type StructData struct {
	Name   string
	Fields []FieldData
}

func main() {
	var structs []StructData

	// 1. Build a registry of "Known Types" that we are generating code for.
	// We use this to decide if we should call MergeX() or just do an assignment.
	knownTypes := make(map[string]bool)
	for _, obj := range targetTypes {
		t := reflect.TypeOf(obj)
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}
		knownTypes[t.Name()] = true
	}

	// 2. Iterate and inspect fields
	for _, obj := range targetTypes {
		t := reflect.TypeOf(obj)
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}

		sd := StructData{Name: t.Name()}

		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)

			if !f.IsExported() {
				continue
			}

			// We cannot determine if a non-pointer (int, string) is set or default zero.
			if f.Type.Kind() != reflect.Ptr {
				continue
			}

			fd := FieldData{Name: f.Name}

			// Check if it's a pointer to a struct
			if f.Type.Kind() == reflect.Ptr && f.Type.Elem().Kind() == reflect.Struct {
				elemName := f.Type.Elem().Name()

				// CRITICAL CHECK:
				// Only mark as "Mergeable" if we are actually generating a Merge function
				// for this specific type. Otherwise, treat it as a scalar (like time.Time).
				if knownTypes[elemName] {
					fd.IsMergeableStruct = true
					fd.TypeName = elemName
				}
			}

			sd.Fields = append(sd.Fields, fd)
		}
		structs = append(structs, sd)
	}

	// 3. Generate Code
	t := template.Must(template.New("merge").Parse(mergeTmpl))
	if err := t.Execute(os.Stdout, structs); err != nil {
		panic(err)
	}
}
