package main

import (
	"os"
	"reflect"
	"text/template"
)

type NetworkPatch struct {
	IP         *string
	MacAddress *string
}

type AgentPatch struct {
	Phase *string
	// Nested Struct Pointer
	Network *NetworkPatch
}

// Config: Add all structs you want to generate Merge logic for here
var targetTypes = []interface{}{
	AgentPatch{},
	NetworkPatch{}, // Nested structs must also be listed
}

const mergeTmpl = `
// Code generated by scripts/gen_merge.go; DO NOT EDIT.
package api

{{ range . }}
func Merge{{ .Name }}(existing, new *{{ .Name }}) {
	if new == nil {
		return
	}
{{- range .Fields }}
	{{- if .IsStructPtr }}
	// Recursive Merge for {{ .Name }}
	if new.{{ .Name }} != nil {
		if existing.{{ .Name }} == nil {
			// Deep Copy needed if you want total safety, but pointer assignment is std for patches
			existing.{{ .Name }} = new.{{ .Name }}
		} else {
			Merge{{ .TypeName }}(existing.{{ .Name }}, new.{{ .Name }})
		}
	}
	{{- else }}
	// Primitive Merge for {{ .Name }}
	if new.{{ .Name }} != nil {
		existing.{{ .Name }} = new.{{ .Name }}
	}
	{{- end }}
{{- end }}
}
{{ end }}
`

type FieldData struct {
	Name        string
	IsStructPtr bool
	TypeName    string
}

type StructData struct {
	Name   string
	Fields []FieldData
}

func main() {
	var structs []StructData

	for _, obj := range targetTypes {
		t := reflect.TypeOf(obj)

		// Handle pointer to struct vs struct
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}

		sd := StructData{Name: t.Name()}

		for i := 0; i < t.NumField(); i++ {
			f := t.Field(i)

			// Skip unexported fields
			if f.PkgPath != "" {
				continue
			}

			fd := FieldData{Name: f.Name}

			// Detect if this is a pointer to a struct (Nested Patch)
			if f.Type.Kind() == reflect.Ptr && f.Type.Elem().Kind() == reflect.Struct {
				fd.IsStructPtr = true
				fd.TypeName = f.Type.Elem().Name()
			}

			sd.Fields = append(sd.Fields, fd)
		}
		structs = append(structs, sd)
	}

	// Generate Code
	t := template.Must(template.New("merge").Parse(mergeTmpl))

	// Print to stdout (or redirect to file)
	if err := t.Execute(os.Stdout, structs); err != nil {
		panic(err)
	}
}
